# claude-memory-framework Conventions

## Guiding Principle

> Claude must be able to orient itself in â‰¤30 seconds: read the root index, identify what it needs, and navigate to the correct document without loading unnecessary context.

---

## Layered Memory Architecture

### Layer 1: Root Index
- Recommended maximum ~70 lines. Only contains: system overview, navigation table, persistence rules.
- Does **NOT** contain: credentials, builds, changelogs, project status, lessons learned.
- Never duplicate information that exists in other documents â€” only point to them with references.

### Layer 2: Reference Documents
- Specialized documents: ARCHITECTURE, CREDENTIALS, BUILD_COMMANDS, etc.
- Each document has a single purpose. If a piece of data fits in more than one document, it goes in the most specific one.
- The project container holds the working memory for active projects.

### Layer 3: Module Context
- Describe the code **as it IS**: what the module does, what patterns it follows, known pitfalls.
- Do **NOT** contain: project status, changelogs, pending tasks.
- They are stable â€” they only change when the code they accompany changes.
- **Always live on disk alongside the code**, regardless of provider. Claude Code reads them natively. They are code documentation, not project documentation.

### Separation Rule

| Type of information                          | Where it goes                                              |
|----------------------------------------------|------------------------------------------------------------|
| What this module does, patterns, pitfalls    | Module context document for `src/{module}/`                |
| Scope, requirements, acceptance criteria     | Project's SPECIFICATIONS document                          |
| Prior analysis, mappings, constraints        | Project's TECHNICAL_ANALYSIS document                      |
| Phase plan, files, order                     | Project's PLAN document                                    |
| Deliverable technical documentation          | Project's TECHNICAL_REPORT document                        |
| Project status, next step                    | Project's CURRENT_STATUS document                          |
| Test scenarios, edge cases, acceptance tests | Project's TESTING document                                 |
| Project change history                       | Project's CHANGELOG document                               |
| Reusable technical lessons                   | LESSONS_LEARNED document                                   |
| Credentials and endpoints                    | CREDENTIALS document                                       |
| Build commands                               | BUILD_COMMANDS document                                    |
| Global system architecture                   | ARCHITECTURE document                                      |
| User's active projects and project index     | User's project index (`projects/{username}/_INDEX.md`)     |
| Team overview of all users' projects         | Root project index (`projects/_INDEX.md`, optional)        |
| Provider entity ID cache (auto-generated)    | `claude-memory/PROVIDER_CACHE.md` (gitignored, on disk)   |

> **Provider note**: The specific format and location of each document depends on your chosen provider. See `providers/` for details.

---

## Naming

- **UPPERCASE** for reference documents: ARCHITECTURE, CHANGELOG, PLAN, CURRENT_STATUS
- **snake_case** for scripts generated by Claude or the user
- **No spaces**, no special characters, no accents in names
- **No status suffixes** in names â€” status is managed ONLY in the project index
- **Language**: English for document names; content in English or your team's language as needed

## Project Container Naming

- **kebab-case**: `auth-refactor`, `api-migration`, `checkout-fix`
- No status suffixes: ~~`auth-refactor-IN_DEVELOPMENT`~~ â†’ `auth-refactor`
- In multi-user mode, the username is a namespace prefix, NOT part of the project name: `projects/{username}/{project-name}/`

---

## Multi-User Mode

### Overview

The framework supports optional per-user project separation. When a user identity is configured, each user gets an isolated project namespace. Reference documents and module context remain shared at the team level.

### User Identity Resolution

Claude resolves the current user in this order:
1. **`.user` file** at the project root (gitignored) â€” contains just the username on one line
2. **`current_user:` field** in the `## Configuration` section of `CLAUDE.md`

The `.user` file is the recommended approach for teams â€” it avoids git conflicts since `CLAUDE.md` is committed to the repo. For solo developers, setting `current_user` directly in `CLAUDE.md` is fine.

When neither is set, the framework operates in **single-user mode** (backward compatible with all existing behavior).

Username rules:
- Lowercase, alphanumeric, hyphens allowed (e.g., `eugenio`, `maria-g`)
- Must match the user's identity in the external provider if applicable (ClickUp display name, etc.)
- Must be consistent across sessions

### What Is Scoped Per User vs. Shared

| Concept | Scope | Rationale |
|---|---|---|
| Project containers | **Per-user** â€” `projects/{username}/{project-name}/` | Each user's work is isolated |
| Project index | **Per-user** â€” `projects/{username}/_INDEX.md` | Avoids merge conflicts |
| Project documents (CURRENT_STATUS, etc.) | **Per-user** â€” inside the user's project container | Session context is personal |
| Reference documents (ARCHITECTURE, etc.) | **Shared** â€” team-level | Team knowledge |
| Module context (`{module}/CLAUDE.md`) | **Shared** â€” code-level | Code documentation, not project documentation |
| LESSONS_LEARNED | **Shared** â€” team-level | Reusable across the team |
| CREDENTIALS | **Shared** â€” team-level | Same environments for all |

### Path Resolution Rule

When `current_user` is resolved:
- Project container: `projects/{current_user}/{project-name}/`
- Project index: `projects/{current_user}/_INDEX.md`

When `current_user` is NOT set (single-user mode):
- Project container: `projects/{project-name}/`
- Project index: `projects/_INDEX.md`

### Cross-User Access

- Users **CAN** read other users' projects: `"Read maria's CURRENT_STATUS for api-migration"` â†’ navigates to `projects/maria/api-migration/CURRENT_STATUS`
- Users **MUST NOT** write to other users' projects during distillation or normal operations
- Claude enforces this by always writing to the `current_user` namespace
- Shared documents (LESSONS_LEARNED, module context) are writable by any user

### Team Overview Index (optional)

A `projects/_INDEX.md` at the root of the projects area may exist as a team-level overview linking to each user's index. Claude does **NOT** use this for day-to-day navigation â€” it reads `projects/{current_user}/_INDEX.md` instead.

### Per-User Project Index Template

```markdown
# Project Index â€” {username}

> Projects owned by {username}. Single source of truth for their project status.

## Active Projects

| Project           | Status        | Branch                  | Started    | Summary                                |
|-------------------|---------------|-------------------------|------------|----------------------------------------|

## Completed Projects

| Project           | Released   | Tag / Branch            | Summary                                |
|-------------------|------------|-------------------------|----------------------------------------|
```

### Migration from Single-User to Multi-User

1. Create a `.user` file at the project root with your username (add `.user` to `.gitignore`)
2. Create `projects/{your-name}/` (or equivalent in your provider)
3. Move existing project containers into `projects/{your-name}/`
4. Move `projects/_INDEX.md` to `projects/{your-name}/_INDEX.md`
5. (Optional) Create a new `projects/_INDEX.md` as a team overview
6. Verify: ask Claude to read the project index â€” it should find your projects

---

## Project Lifecycle

### 1. Create project
- Create a project container in the projects area (in multi-user mode: `projects/{current_user}/{project-name}/`)
- Create the CURRENT_STATUS document (mandatory from the very start)
- Create the SPECIFICATIONS document with the initial scope, requirements, and acceptance criteria
- Register in the project index with status `PLANNING` (in multi-user mode: the user's own `_INDEX.md`)

### Small Projects (Lite Mode)
If the project is a fix, a scoped refactor, or a task spanning only a few sessions (plan with fewer than 3 phases):
- Only CURRENT_STATUS + CHANGELOG â€” do not create SPECIFICATIONS, TECHNICAL_ANALYSIS, PLAN, TECHNICAL_REPORT, or TESTING
- Requirements, analysis, and plan go as sections inside CURRENT_STATUS
- If the project grows and becomes complex, promote to full structure at that point

### 2. ANALYSIS Phase (status: `PLANNING`)
The first sessions are dedicated to understanding the problem, analyzing the existing code involved, identifying constraints, and defining the approach. These are the sessions that generate the most context and where distillation is most critical.

**Primary output**: TECHNICAL_ANALYSIS
- Analysis of the problem or requirement to be solved
- Existing code involved: modules, classes, patterns, dependencies
- Relevant data structures (tables, models, relationships)
- Constraints and limitations discovered
- Design decisions made prior to development (e.g., "approach X, not Y, because...")
- If it's an API integration: endpoints, auth, rate limits, external data model, field-to-field mappings
- **Impact map** (recommended): existing files affected, tables read/written, artifacts/binaries involved. Helps Claude assess the real scope before planning.

**Audience**: Claude in future sessions. Discarded when the project is closed.

### 3. PLANNING Phase (status: `PLANNING`)
With the analysis done, the concrete implementation plan is defined.

**Primary output**: PLAN
- Ordered phases with description and dependencies
- Files to create or modify per phase, with expected content
- Database changes needed (tables, stored procedures, views, migrations)
- Phase-specific implementation considerations
- Suggested implementation order

**Audience**: Claude in future sessions. Discarded when the project is closed.

### 4. DEVELOPMENT Phase (status: `IN_PROGRESS`)
Iterative implementation phase by phase. Each session produces code and updates memory.

**Primary output**: TECHNICAL_REPORT
- Technical documentation of the project, enriched as development progresses
- Reflects what was built: files, classes, methods, data structures
- Technical decisions made during implementation and their rationale
- Project-specific lessons learned
- Status of each phase (completed / pending)
- File structure of the developed component
- Optionally, a "Notes for the deployer" section. Relevant data to keep in mind when configuring or deploying the feature.
For example, "External dependencies MUST be configured BEFORE running the data import". These are details to keep in mind when setting up the functionality.

**Audience**: Engineering team. **Survives project closure** as deliverable technical documentation.

### 5. TESTING Phase (status: `TESTING`)
Development completed. Validation, QA, pre-production vs production comparison.

**Primary output**: TESTING
- Test scenarios derived from SPECIFICATIONS acceptance criteria
- Edge cases discovered during development or testing
- Test results: passed, failed, pending
- Verification against SPECIFICATIONS: which requirements are met and which are not
- Environment-specific considerations (pre-production vs production differences)

### 6. Complete (status: `RELEASED`)
When the project is released to production:
- TECHNICAL_REPORT â†’ **kept** as technical documentation (move to a permanent documentation area)
- SPECIFICATIONS â†’ **kept** alongside TECHNICAL_REPORT as the original requirements reference
- TESTING â†’ **kept** alongside TECHNICAL_REPORT as the verification record
- TECHNICAL_ANALYSIS, PLAN â†’ can be discarded (their value is already reflected in TECHNICAL_REPORT)
- CHANGELOG â†’ archive if applicable
- Remove the project container from the user's project namespace
- Update the user's project index: move the entry to the "Completed" section
- If the project generated module context documents, those **are kept** (they are code context, not project context)

### Project Statuses (in the project index)

| Status          | Phase                     | Meaning                                          |
|-----------------|---------------------------|--------------------------------------------------|
| `PLANNING`      | Analysis + Planning       | Problem analysis, plan design                    |
| `IN_PROGRESS`   | Development               | Active implementation phase by phase             |
| `TESTING`       | Testing                   | Development done, QA validation                  |
| `READY`         | Pre-release               | Tested and ready for production                  |
| `RELEASED`      | Completed                 | In production (remove project container)         |
| `ON_HOLD`       | Paused                    | Temporarily paused                               |

### Document Evolution Throughout the Project

```
PLANNING          IN_PROGRESS       TESTING         RELEASED
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€       â”€â”€â”€â”€â”€â”€â”€         â”€â”€â”€â”€â”€â”€â”€â”€
CURRENT_STATUS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ (always)
SPECIFICATIONS â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘  (created at project start, survives â†’)
TECHNICAL_ANALYSIS â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘  (created and completed here)
PLAN              â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘  (created here)
CHANGELOG         â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘  (grows here)
TECHNICAL_REPORT   â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  (grows here, survives â†’)
TESTING           â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘  (created here, survives â†’)
Module context    â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  (created/updated here)
```

---

## Standard Project Documents

| Document                 | Mandatory | Created in phase | Audience       | Survives closure |
|--------------------------|-----------|------------------|----------------|------------------|
| CURRENT_STATUS           | Yes       | Project creation | Claude         | No               |
| SPECIFICATIONS           | Yes       | Project creation | Claude/Team    | **Yes**          |
| TECHNICAL_ANALYSIS       | Yes       | Analysis         | Claude         | No               |
| PLAN                     | Yes       | Planning         | Claude         | No               |
| CHANGELOG                | Yes       | Development      | Claude/Team    | Optional         |
| TECHNICAL_REPORT         | Yes       | Development      | Engineering    | **Yes**          |
| TESTING                  | Yes       | Testing          | Claude/Team    | **Yes**          |

### What Goes Where (practical rule)

**In SPECIFICATIONS** â€” What is being asked for:
- Scope: what the project must accomplish
- Functional requirements: what the system must do
- Non-functional requirements: performance, security, compatibility constraints
- Acceptance criteria: how to know each requirement is met
- Out of scope: what is explicitly NOT part of this project

**In TECHNICAL_ANALYSIS** â€” What Claude discovers during investigation:
- Existing code involved, affected modules, dependencies
- Relevant data structures, relationships between tables
- Technical constraints, limitations, edge cases
- Design decisions prior to development
- If it's an API integration: endpoints, auth, rate limits, field-to-field mappings

**In PLAN** â€” What Claude is going to do:
- Ordered phases with files to create/modify
- Dependencies between phases
- Database changes, wiring, configuration

**In TECHNICAL_REPORT** â€” What Claude has built:
- Files created, classes, methods, constants
- Technical decisions made during implementation
- Project-specific lessons learned

**In CURRENT_STATUS** â€” Where we are now:
- What was completed, what remains, concrete next step

**In CHANGELOG** â€” What changed and when:
- Code changes with files and reason

**In TESTING** â€” How we verify what was built:
- Test scenarios tied to SPECIFICATIONS acceptance criteria
- Edge cases and negative tests
- Test results and pass/fail status
- Environment-specific notes

**In LESSONS_LEARNED** â€” What's reusable across projects:
- Only lessons that apply beyond this specific project

### Key Difference Between the Technical Documents

```
SPECIFICATIONS  â†’ TECHNICAL_ANALYSIS â†’ PLAN          â†’ TECHNICAL_REPORT â†’ TESTING
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”€â”€â”€â”€â”€â”€          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”€â”€â”€â”€â”€â”€â”€
What is asked?    What exists?         What to do?     What was built?      Does it work?

Requirements,     Existing code,       Phases, files,  Classes, methods,    Test scenarios,
acceptance        constraints,         order, deps,    technical decisions, results,
criteria,         data structures,     DB changes,     lessons, file        edge cases,
scope             prior decisions      configuration   structure            verification

For Claude/Team   For Claude           For Claude      For Engineering      For Claude/Team
Survives          Discarded            Discarded       Delivered            Survives
```

---

## Module Context Document (template)

```markdown
# {Module Name}

## What this is
- Description in 2-3 lines of what this module does

## Dependencies
- Framework, libraries, and references used by this module
- E.g.: "React 18, TanStack Query v5, Zod for validation" or "Django 4.2, Celery, PostgreSQL 15"

## Key patterns
- Design patterns and important conventions in the module

## Files
- List of files with a one-line description

## Watch out
- Known pitfalls, common mistakes, things NOT to do
```

Guidelines:
- Maximum ~50 lines. If it needs more, something belongs in a different document.
- Direct, imperative language: "Always validate input before processing", "Never call this method outside the main thread".
- Only information Claude needs to work with the code â€” no history or changelogs.
- The Dependencies section is especially important in legacy stacks or frameworks with constrained versions: Claude tends to suggest APIs from newer versions that may not be available.

---

## Session Distillation Protocol

### The Problem
Claude Code's context window runs out. If you don't distill before that happens, the session's work is lost or trapped in conversation transcripts that are noisy and inefficient to reprocess.

### The Principle
> **Each session starts by reading clean documents and ends by updating them.** Never depend on conversation transcripts as a memory source.

### Distillation Triggers
Claude MUST execute the distillation protocol when:
1. **The user asks for it** â€” key phrases: "consolidate", "distill", "save progress", "persist the session"
2. **The context is filling up** â€” Claude must propose it proactively
3. **A significant block of work is completed** â€” a phase, an important fix, an analysis
4. **Before switching topics** â€” if transitioning from analysis to coding or vice versa

### What to Update (checklist by phase)

**During ANALYSIS sessions:**
| Document | Priority | What to write |
|------|----------|---------------|
| TECHNICAL_ANALYSIS | **Primary** | Findings: existing code, data structures, constraints, design decisions |
| SPECIFICATIONS | If requirements changed | Update scope, acceptance criteria, clarified constraints |
| CURRENT_STATUS | **ALWAYS** | "Analysis of X completed, still need to analyze Y" |

**During PLANNING sessions:**
| Document | Priority | What to write |
|------|----------|---------------|
| PLAN | **Primary** | Phases, files to create/modify, order, dependencies |
| TECHNICAL_ANALYSIS | If applicable | Enrich if new findings emerged while planning |
| CURRENT_STATUS | **ALWAYS** | "Plan completed, next step: implement phase 1" |

**During DEVELOPMENT sessions:**
| Document | Priority | What to write |
|------|----------|---------------|
| CURRENT_STATUS | **ALWAYS** | What was done, what's left, concrete next step to resume |
| TECHNICAL_REPORT | **Primary** | Document what was built: classes, methods, technical decisions |
| CHANGELOG | If there were changes | Concrete changes with files and reason |
| LESSONS_LEARNED | If applicable | Only if reusable across projects |
| Module context | **Mandatory if module logic was modified** | Updated patterns, pitfalls, files, dependencies |

**During TESTING sessions:**
| Document | Priority | What to write |
|------|----------|---------------|
| TESTING | **Primary** | Test scenarios, results, edge cases, verification against SPECIFICATIONS |
| CURRENT_STATUS | **ALWAYS** | What was tested, what passed/failed, next step |
| TECHNICAL_REPORT | If applicable | Update with testing-related technical findings |

### CURRENT_STATUS Format When Distilling

```markdown
**Last updated**: YYYY-MM-DD
**Last session summary**: [1-2 sentences of what was done]
**Next step**: [Concrete action to resume â€” not "continue development"]
**Done when**: [Verification condition â€” how to know the next step is completed]

## Done
- âœ… What's completed (cumulative)

## In Progress
- ðŸ”„ What's in progress + exact state

## Next Steps
- [ ] What's pending, ordered by priority

## Blockers
- (if any)
```

The key to `**Next step**` is that it must be **concrete enough that Claude can resume without asking anything**.
The key to `**Done when**` is that it must be **verifiable**: a command, a result, a passing test.

Examples:
- âŒ Next step: "Continue with phase 3" / Done when: "When it's ready"
- âœ… Next step: "Implement UserService.validate(): add email format check + duplicate detection against DB"
- âœ… Done when: "All tests in test_user_service.py pass + manual test: registering duplicate email returns 409"

### Full Workflow Between Sessions

```
Session N
  â”œâ”€â”€ Claude reads current_user (from .user file or CLAUDE.md)
  â”œâ”€â”€ Claude reads PROVIDER_CACHE.md â†’ has all entity IDs (external providers only)
  â”œâ”€â”€ Claude reads projects/{current_user}/_INDEX.md â†’ knows active projects
  â”œâ”€â”€ Claude reads CURRENT_STATUS â†’ knows exactly where to resume
  â”œâ”€â”€ If it needs analysis context â†’ reads TECHNICAL_ANALYSIS
  â”œâ”€â”€ If it needs the plan â†’ reads PLAN
  â”œâ”€â”€ If it needs code context â†’ reads the module context document
  â”œâ”€â”€ Work together (analysis, code, decisions...)
  â”œâ”€â”€ âš ï¸ Distillation trigger detected
  â”‚     â”œâ”€â”€ Claude proposes: "I'm going to consolidate the session progress"
  â”‚     â”œâ”€â”€ Claude updates documents in current_user's namespace
  â”‚     â””â”€â”€ If new entities were created â†’ updates PROVIDER_CACHE.md
  â””â”€â”€ End of session â€” clean context for the next one

Session N+1
  â”œâ”€â”€ Claude reads current_user â†’ scopes to the user's namespace
  â”œâ”€â”€ Claude reads CURRENT_STATUS (â‰¤50 lines, ~10 sec of context)
  â”œâ”€â”€ Reads "Next step" â†’ knows the concrete action
  â”œâ”€â”€ If there's a "Done when" from the previous session â†’ recommended to validate before moving forward
  â””â”€â”€ Starts without having loaded any transcripts from previous sessions
```

> **Multi-user note**: Distillation targets only the `current_user`'s project namespace. Shared documents (LESSONS_LEARNED, module context) are updated normally regardless of user.

### Anti-pattern: conversation transcripts
- Do **NOT** save conversations as files to "remember"
- Do **NOT** ask Claude to read transcripts from past sessions
- If a transcript already exists and has valuable info â†’ distill to structured documents and discard the transcript
- Everything valuable from a conversation **must be distilled** before it ends

### Staleness Rule
If Claude reads a CURRENT_STATUS whose `Last updated` date is more than 48 hours old, it must ask the user if the information is still valid before assuming it is. Code may have changed outside of Claude (manual hotfixes, merges from other developers, DB changes).

In multi-user mode, the staleness rule applies per user. Only the `current_user`'s CURRENT_STATUS age matters â€” other users' document ages are irrelevant to the current session.

---

## Persistence Rules

1. Distill at the end of every session or significant block of work (mandatory)
2. Reusable technical finding â†’ LESSONS_LEARNED
3. New useful command â†’ BUILD_COMMANDS or a scripts container
4. New pattern or pitfall in a module â†’ module context document
5. **If a session modifies a module's architecture, patterns, or dependencies, updating its module context is mandatory** â€” not optional
6. **Never duplicate** â€” if data already exists in another document, reference it
7. New credentials â†’ CREDENTIALS (remember: this document must not be versioned / must have restricted access)
8. Operational debugging guides (timeouts, incorrect counts, cache) â†’ TESTING_METHODOLOGY

## LESSONS_LEARNED Structure

Organize by categories with `##` headers:
```markdown
## Concurrency
- Race condition in shared cache â†’ always use locks or thread-safe collections
- ...

## API / Networking
- ...

## Database
- ...
```

**Pruning rule**: LESSONS_LEARNED acts as an incubator, not a permanent archive. When a lesson matures and becomes a standard for a specific module, it should be moved to that module's context document ("Watch out" section) and removed from the general document.

**Size trigger**: When LESSONS_LEARNED exceeds 30 entries, Claude must prune during distillation: review all entries, move mature lessons to the relevant module context documents, and remove them from LESSONS_LEARNED. If no entries qualify for migration, consolidate related entries or archive obsolete ones. The goal is to stay under the threshold.

## Cross-referencing Rule

Before creating something new, Claude must **read the existing equivalent first** as a reference:
- New service â†’ read the context and code of an existing similar service
- New form â†’ read a similar existing form
- New stored procedure â†’ read an equivalent SP following the same pattern
- New module â†’ read the context document of a similar module

This applies to any type of project, not just integrations.

## Log Access Rule

Claude must **never** read all items in a logs container at once. It must read only the specific entry it is debugging. Loading multiple logs floods the context unnecessarily.

## Temporary Data

Temporary files, intermediate outputs, and ephemeral data generated during a session (e.g., exported data, test payloads, diff snapshots) should be stored in a designated temporary area. This data can be cleaned at any time.

---

## Version Control

How changes to documents are tracked depends on the provider:
- **Markdown files**: git commits, branches, `.gitignore` for sensitive documents
- **ClickUp / Notion / etc.**: Native edit history, restricted permissions for sensitive documents

See your provider's MAPPING.md for specific version control guidance.

### Documents that must NOT be publicly versioned
- CREDENTIALS (sensitive)
- PROVIDER_CACHE (auto-generated, machine-specific)
- Logs (heavy, temporary)
- Temporary data (ephemeral)

---

## Provider Cache

### Purpose

External/hybrid providers require entity ID lookups (Space IDs, Folder IDs, List IDs, Doc IDs) for every MCP operation. The Provider Cache eliminates this overhead by mapping framework document names to provider-specific entity IDs on disk.

### Scope

- **Required for**: External and hybrid providers (ClickUp, Notion, etc.) that access documents via MCP tools
- **Not needed for**: The markdown-files provider (all documents are local files â€” no IDs to cache)
- **File location**: `claude-memory/PROVIDER_CACHE.md` (gitignored â€” never committed to version control)

### Cache Rules

1. **Auto-generated** â€” Claude generates the cache file, never the user
2. **Gitignored** â€” The cache is local and machine-specific; never committed
3. **Read on startup** â€” Claude reads PROVIDER_CACHE.md alongside CLAUDE.md at the start of every session (if it exists)
4. **Use cached IDs first** â€” When the cache has an ID for an entity, Claude uses it directly instead of searching/listing via MCP
5. **Update on create** â€” When Claude creates a new entity (project folder, document, etc.), it appends the new ID to the cache immediately
6. **Regenerate if missing** â€” If the file is missing, Claude generates it by querying the provider for all known entities
7. **Regenerate if corrupted** â€” If a cached ID produces a "not found" error, Claude regenerates the entire cache from scratch
8. **Multi-user safe** â€” The cache contains workspace-level IDs (Spaces, Folders, Lists) shared across all users. It does not contain user-specific data.

### Cache Lifecycle

| Event | Action |
|---|---|
| First session with external provider (no cache file) | Claude generates the cache by querying the provider |
| Session start | Claude reads the cache file alongside CLAUDE.md |
| Claude creates a new entity (project, document) | Claude appends the new ID to the cache |
| Cached ID returns "not found" from provider | Claude regenerates the entire cache |
| Cache file manually deleted | Same as "first session" â€” Claude regenerates |

### Cache Template

The exact structure depends on the provider. See the provider's `MAPPING.md` for the provider-specific cache template. The general format is:

```markdown
# Provider Cache
> Auto-generated by Claude. Do not edit manually.
> Provider: {provider-name}
> Generated: {YYYY-MM-DD}

## Workspace
- Workspace ID: ...
- Space/Container ID: ...

## Reference Documents
| Document | ID | Type |
|---|---|---|
| ... | ... | ... |

## Project Infrastructure
| Entity | ID | Type |
|---|---|---|
| ... | ... | ... |

## Projects
| Project | Container ID | Documents |
|---|---|---|
| ... | ... | DOC_NAME: id, ... |
```
