# claude-memory-framework Conventions

## Guiding Principle

> Claude must be able to orient itself in ‚â§30 seconds: read the root index, identify what it needs, and navigate to the correct document without loading unnecessary context.

---

## Layered Memory Architecture

### Layer 1: Root Index
- Recommended maximum ~70 lines. Only contains: system overview, navigation table, persistence rules.
- Does **NOT** contain: credentials, builds, changelogs, project status, lessons learned.
- Never duplicate information that exists in other documents ‚Äî only point to them with references.

### Layer 2: Reference Documents
- Specialized documents: ARCHITECTURE, CREDENTIALS, BUILD_COMMANDS, etc.
- Each document has a single purpose. If a piece of data fits in more than one document, it goes in the most specific one.
- The project container holds the working memory for active projects.

### Layer 3: Module Context
- Describe the code **as it IS**: what the module does, what patterns it follows, known pitfalls.
- Do **NOT** contain: project status, changelogs, pending tasks.
- They are stable ‚Äî they only change when the code they accompany changes.
- **Always live on disk alongside the code**, regardless of provider. Claude Code reads them natively. They are code documentation, not project documentation.

### Separation Rule

| Type of information                          | Where it goes                                              |
|----------------------------------------------|------------------------------------------------------------|
| What this module does, patterns, pitfalls    | Module context document for `src/{module}/`                |
| Prior analysis, mappings, constraints        | Project's TECHNICAL_ANALYSIS document                      |
| Phase plan, files, order                     | Project's PLAN document                                    |
| Deliverable technical documentation          | Project's TECHNICAL_REPORT document                        |
| Project status, next step                    | Project's CURRENT_STATUS document                          |
| Project change history                       | Project's CHANGELOG document                               |
| Reusable technical lessons                   | LESSONS_LEARNED document                                   |
| Credentials and endpoints                    | CREDENTIALS document                                       |
| Build commands                               | BUILD_COMMANDS document                                    |
| Global system architecture                   | ARCHITECTURE document                                      |

> **Provider note**: The specific format and location of each document depends on your chosen provider. See `providers/` for details.

---

## Naming

- **UPPERCASE** for reference documents: ARCHITECTURE, CHANGELOG, PLAN, CURRENT_STATUS
- **snake_case** for scripts generated by Claude or the user
- **No spaces**, no special characters, no accents in names
- **No status suffixes** in names ‚Äî status is managed ONLY in the project index
- **Language**: English for document names; content in English or your team's language as needed

## Project Container Naming

- **kebab-case**: `auth-refactor`, `api-migration`, `checkout-fix`
- No status suffixes: ~~`auth-refactor-IN_DEVELOPMENT`~~ ‚Üí `auth-refactor`

---

## Project Lifecycle

### 1. Create project
- Create a project container in the projects area
- Create the CURRENT_STATUS document (mandatory from the very start)
- Register in the project index with status `PLANNING`

### Small Projects (Lite Mode)
If the project is a fix, a scoped refactor, or a task spanning only a few sessions (plan with fewer than 3 phases):
- Only CURRENT_STATUS + CHANGELOG ‚Äî do not create TECHNICAL_ANALYSIS, PLAN, or TECHNICAL_REPORT
- Analysis and plan go as sections inside CURRENT_STATUS
- If the project grows and becomes complex, promote to full structure at that point

### 2. ANALYSIS Phase (status: `PLANNING`)
The first sessions are dedicated to understanding the problem, analyzing the existing code involved, identifying constraints, and defining the approach. These are the sessions that generate the most context and where distillation is most critical.

**Primary output**: TECHNICAL_ANALYSIS
- Analysis of the problem or requirement to be solved
- Existing code involved: modules, classes, patterns, dependencies
- Relevant data structures (tables, models, relationships)
- Constraints and limitations discovered
- Design decisions made prior to development (e.g., "approach X, not Y, because...")
- If it's an API integration: endpoints, auth, rate limits, external data model, field-to-field mappings
- **Impact map** (recommended): existing files affected, tables read/written, artifacts/binaries involved. Helps Claude assess the real scope before planning.

**Audience**: Claude in future sessions. Discarded when the project is closed.

### 3. PLANNING Phase (status: `PLANNING`)
With the analysis done, the concrete implementation plan is defined.

**Primary output**: PLAN
- Ordered phases with description and dependencies
- Files to create or modify per phase, with expected content
- Database changes needed (tables, stored procedures, views, migrations)
- Phase-specific implementation considerations
- Suggested implementation order

**Audience**: Claude in future sessions. Discarded when the project is closed.

### 4. DEVELOPMENT Phase (status: `IN_PROGRESS`)
Iterative implementation phase by phase. Each session produces code and updates memory.

**Primary output**: TECHNICAL_REPORT
- Technical documentation of the project, enriched as development progresses
- Reflects what was built: files, classes, methods, data structures
- Technical decisions made during implementation and their rationale
- Project-specific lessons learned
- Status of each phase (completed / pending)
- File structure of the developed component
- Optionally, a "Notes for the deployer" section. Relevant data to keep in mind when configuring or deploying the feature.
For example, "External dependencies MUST be configured BEFORE running the data import". These are details to keep in mind when setting up the functionality.

**Audience**: Engineering team. **Survives project closure** as deliverable technical documentation.

### 5. TESTING Phase (status: `TESTING`)
Development completed. Validation, QA, pre-production vs production comparison.

### 6. Complete (status: `RELEASED`)
When the project is released to production:
- TECHNICAL_REPORT ‚Üí **kept** as technical documentation (move to a permanent documentation area)
- TECHNICAL_ANALYSIS, PLAN ‚Üí can be discarded (their value is already reflected in TECHNICAL_REPORT)
- CHANGELOG ‚Üí archive if applicable
- Remove the project container from the projects area
- Update the project index: move the entry to the "Completed" section
- If the project generated module context documents, those **are kept** (they are code context, not project context)

### Project Statuses (in the project index)

| Status          | Phase                     | Meaning                                          |
|-----------------|---------------------------|--------------------------------------------------|
| `PLANNING`      | Analysis + Planning       | Problem analysis, plan design                    |
| `IN_PROGRESS`   | Development               | Active implementation phase by phase             |
| `TESTING`       | Testing                   | Development done, QA validation                  |
| `READY`         | Pre-release               | Tested and ready for production                  |
| `RELEASED`      | Completed                 | In production (remove project container)         |
| `ON_HOLD`       | Paused                    | Temporarily paused                               |

### Document Evolution Throughout the Project

```
PLANNING          IN_PROGRESS       TESTING         RELEASED
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ        ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ       ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ         ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
CURRENT_STATUS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí (always)
TECHNICAL_ANALYSIS ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë  (created and completed here)
PLAN              ‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë  (created here)
CHANGELOG         ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë  (grows here)
TECHNICAL_REPORT   ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  (grows here, survives ‚Üí)
Module context    ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  (created/updated here)
```

---

## Standard Project Documents

| Document                 | Mandatory | Created in phase | Audience       | Survives closure |
|--------------------------|-----------|------------------|----------------|------------------|
| CURRENT_STATUS           | Yes       | Project creation | Claude         | No               |
| TECHNICAL_ANALYSIS       | Yes       | Analysis         | Claude         | No               |
| PLAN                     | Yes       | Planning         | Claude         | No               |
| CHANGELOG                | Yes       | Development      | Claude/Team    | Optional         |
| TECHNICAL_REPORT         | Yes       | Development      | Engineering    | **Yes**          |

### What Goes Where (practical rule)

**In TECHNICAL_ANALYSIS** ‚Äî What Claude discovers during investigation:
- Existing code involved, affected modules, dependencies
- Relevant data structures, relationships between tables
- Technical constraints, limitations, edge cases
- Design decisions prior to development
- If it's an API integration: endpoints, auth, rate limits, field-to-field mappings

**In PLAN** ‚Äî What Claude is going to do:
- Ordered phases with files to create/modify
- Dependencies between phases
- Database changes, wiring, configuration

**In TECHNICAL_REPORT** ‚Äî What Claude has built:
- Files created, classes, methods, constants
- Technical decisions made during implementation
- Project-specific lessons learned

**In CURRENT_STATUS** ‚Äî Where we are now:
- What was completed, what remains, concrete next step

**In CHANGELOG** ‚Äî What changed and when:
- Code changes with files and reason

**In LESSONS_LEARNED** ‚Äî What's reusable across projects:
- Only lessons that apply beyond this specific project

### Key Difference Between the Three Technical Documents

```
TECHNICAL_ANALYSIS          PLAN                       TECHNICAL_REPORT
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ       ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
What are we working with? ‚Üí What are we going to do? ‚Üí What have we built?

Existing code,              Phases, files,             Classes, methods,
constraints,                order, dependencies,       technical decisions,
data structures,            DB changes,                lessons, file
prior decisions             configuration              structure

For Claude                  For Claude                 For Engineering
Discarded                   Discarded                  Delivered
```

---

## Module Context Document (template)

```markdown
# {Module Name}

## What this is
- Description in 2-3 lines of what this module does

## Dependencies
- Framework, libraries, and references used by this module
- E.g.: "React 18, TanStack Query v5, Zod for validation" or "Django 4.2, Celery, PostgreSQL 15"

## Key patterns
- Design patterns and important conventions in the module

## Files
- List of files with a one-line description

## Watch out
- Known pitfalls, common mistakes, things NOT to do
```

Guidelines:
- Maximum ~50 lines. If it needs more, something belongs in a different document.
- Direct, imperative language: "Always validate input before processing", "Never call this method outside the main thread".
- Only information Claude needs to work with the code ‚Äî no history or changelogs.
- The Dependencies section is especially important in legacy stacks or frameworks with constrained versions: Claude tends to suggest APIs from newer versions that may not be available.

---

## Session Distillation Protocol

### The Problem
Claude Code's context window runs out. If you don't distill before that happens, the session's work is lost or trapped in conversation transcripts that are noisy and inefficient to reprocess.

### The Principle
> **Each session starts by reading clean documents and ends by updating them.** Never depend on conversation transcripts as a memory source.

### Distillation Triggers
Claude MUST execute the distillation protocol when:
1. **The user asks for it** ‚Äî key phrases: "consolidate", "distill", "save progress", "persist the session"
2. **The context is filling up** ‚Äî Claude must propose it proactively
3. **A significant block of work is completed** ‚Äî a phase, an important fix, an analysis
4. **Before switching topics** ‚Äî if transitioning from analysis to coding or vice versa

### What to Update (checklist by phase)

**During ANALYSIS sessions:**
| Document | Priority | What to write |
|------|----------|---------------|
| TECHNICAL_ANALYSIS | **Primary** | Findings: existing code, data structures, constraints, design decisions |
| CURRENT_STATUS | **ALWAYS** | "Analysis of X completed, still need to analyze Y" |

**During PLANNING sessions:**
| Document | Priority | What to write |
|------|----------|---------------|
| PLAN | **Primary** | Phases, files to create/modify, order, dependencies |
| TECHNICAL_ANALYSIS | If applicable | Enrich if new findings emerged while planning |
| CURRENT_STATUS | **ALWAYS** | "Plan completed, next step: implement phase 1" |

**During DEVELOPMENT sessions:**
| Document | Priority | What to write |
|------|----------|---------------|
| CURRENT_STATUS | **ALWAYS** | What was done, what's left, concrete next step to resume |
| TECHNICAL_REPORT | **Primary** | Document what was built: classes, methods, technical decisions |
| CHANGELOG | If there were changes | Concrete changes with files and reason |
| LESSONS_LEARNED | If applicable | Only if reusable across projects |
| Module context | **Mandatory if module logic was modified** | Updated patterns, pitfalls, files, dependencies |

### CURRENT_STATUS Format When Distilling

```markdown
**Last updated**: YYYY-MM-DD
**Last session summary**: [1-2 sentences of what was done]
**Next step**: [Concrete action to resume ‚Äî not "continue development"]
**Done when**: [Verification condition ‚Äî how to know the next step is completed]

## Done
- ‚úÖ What's completed (cumulative)

## In Progress
- üîÑ What's in progress + exact state

## Next Steps
- [ ] What's pending, ordered by priority

## Blockers
- (if any)
```

The key to `**Next step**` is that it must be **concrete enough that Claude can resume without asking anything**.
The key to `**Done when**` is that it must be **verifiable**: a command, a result, a passing test.

Examples:
- ‚ùå Next step: "Continue with phase 3" / Done when: "When it's ready"
- ‚úÖ Next step: "Implement UserService.validate(): add email format check + duplicate detection against DB"
- ‚úÖ Done when: "All tests in test_user_service.py pass + manual test: registering duplicate email returns 409"

### Full Workflow Between Sessions

```
Session N
  ‚îú‚îÄ‚îÄ Claude reads CURRENT_STATUS ‚Üí knows exactly where to resume
  ‚îú‚îÄ‚îÄ If it needs analysis context ‚Üí reads TECHNICAL_ANALYSIS
  ‚îú‚îÄ‚îÄ If it needs the plan ‚Üí reads PLAN
  ‚îú‚îÄ‚îÄ If it needs code context ‚Üí reads the module context document
  ‚îú‚îÄ‚îÄ Work together (analysis, code, decisions...)
  ‚îú‚îÄ‚îÄ ‚ö†Ô∏è Distillation trigger detected
  ‚îÇ     ‚îú‚îÄ‚îÄ Claude proposes: "I'm going to consolidate the session progress"
  ‚îÇ     ‚îî‚îÄ‚îÄ Claude updates documents according to the current phase checklist
  ‚îî‚îÄ‚îÄ End of session ‚Äî clean context for the next one

Session N+1
  ‚îú‚îÄ‚îÄ Claude reads CURRENT_STATUS (‚â§50 lines, ~10 sec of context)
  ‚îú‚îÄ‚îÄ Reads "Next step" ‚Üí knows the concrete action
  ‚îú‚îÄ‚îÄ If there's a "Done when" from the previous session ‚Üí recommended to validate before moving forward
  ‚îî‚îÄ‚îÄ Starts without having loaded any transcripts from previous sessions
```

### Anti-pattern: conversation transcripts
- Do **NOT** save conversations as files to "remember"
- Do **NOT** ask Claude to read transcripts from past sessions
- If a transcript already exists and has valuable info ‚Üí distill to structured documents and discard the transcript
- Everything valuable from a conversation **must be distilled** before it ends

### Staleness Rule
If Claude reads a CURRENT_STATUS whose `Last updated` date is more than 48 hours old, it must ask the user if the information is still valid before assuming it is. Code may have changed outside of Claude (manual hotfixes, merges from other developers, DB changes).

---

## Persistence Rules

1. Distill at the end of every session or significant block of work (mandatory)
2. Reusable technical finding ‚Üí LESSONS_LEARNED
3. New useful command ‚Üí BUILD_COMMANDS or a scripts container
4. New pattern or pitfall in a module ‚Üí module context document
5. **If a session modifies a module's architecture, patterns, or dependencies, updating its module context is mandatory** ‚Äî not optional
6. **Never duplicate** ‚Äî if data already exists in another document, reference it
7. New credentials ‚Üí CREDENTIALS (remember: this document must not be versioned / must have restricted access)
8. Operational debugging guides (timeouts, incorrect counts, cache) ‚Üí TESTING_METHODOLOGY

## LESSONS_LEARNED Structure

Organize by categories with `##` headers:
```markdown
## Concurrency
- Race condition in shared cache ‚Üí always use locks or thread-safe collections
- ...

## API / Networking
- ...

## Database
- ...
```

**Pruning rule**: LESSONS_LEARNED acts as an incubator. When a lesson matures and becomes a standard for a specific module, it should be moved to that module's context document ("Watch out" section) and removed from the general document. This keeps LESSONS_LEARNED focused on knowledge pending consolidation.

## Cross-referencing Rule

Before creating something new, Claude must **read the existing equivalent first** as a reference:
- New service ‚Üí read the context and code of an existing similar service
- New form ‚Üí read a similar existing form
- New stored procedure ‚Üí read an equivalent SP following the same pattern
- New module ‚Üí read the context document of a similar module

This applies to any type of project, not just integrations.

## Log Access Rule

Claude must **never** read all items in a logs container at once. It must read only the specific entry it is debugging. Loading multiple logs floods the context unnecessarily.

## Temporary Data

Temporary files, intermediate outputs, and ephemeral data generated during a session (e.g., exported data, test payloads, diff snapshots) should be stored in a designated temporary area. This data can be cleaned at any time.

---

## Version Control

How changes to documents are tracked depends on the provider:
- **Markdown files**: git commits, branches, `.gitignore` for sensitive documents
- **ClickUp / Notion / etc.**: Native edit history, restricted permissions for sensitive documents

See your provider's MAPPING.md for specific version control guidance.

### Documents that must NOT be publicly versioned
- CREDENTIALS (sensitive)
- Logs (heavy, temporary)
- Temporary data (ephemeral)
