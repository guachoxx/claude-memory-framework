# claude-memory-framework Conventions

## Guiding Principle

> Claude must be able to orient itself in â‰¤30 seconds: read the root index, identify what it needs, and navigate to the correct document without loading unnecessary context.

---

## Boot Sequence

Every session starts with this sequence, regardless of provider:

1. **Read `CLAUDE.md`** (on disk) â€” project overview, navigation, boot instructions
2. **Read `claude-memory/CONFIG.md`** (on disk, gitignored) â€” provider type, user identity, connection settings
   - If missing: ask the user to create it. See `claude-memory/providers/` for setup instructions.
   - Verify the configured provider is accessible (MCP server connected or API key set).
3. **Read CONVENTIONS** (from provider) â€” operational rules for the framework. **This is mandatory on every session**, warm or cold.
4. **Read `claude-memory/PROVIDER_CACHE.md`** (on disk, gitignored) â€” cached entity IDs
   - If exists â†’ **warm start**: all IDs available, skip discovery
   - If missing â†’ **cold start**: discover provider structure using CONFIG.md settings, generate the cache
5. Ready to work. Read the active project's CURRENT STATUS if resuming work.

> **Why CONVENTIONS first**: CONVENTIONS defines how Claude operates â€” distillation rules, naming, lifecycle, persistence. Without it, Claude cannot correctly create, update, or organize documents. It must be loaded before any project work begins.

---

## Layered Memory Architecture

### Layer 1: Root Index and Configuration
- **`CLAUDE.md`** (on disk, project root): Recommended maximum ~70 lines. Only contains: system overview, boot sequence, navigation table, persistence rules summary.
- **`claude-memory/CONFIG.md`** (on disk, gitignored): Provider type, connection settings, user identity. Per-user, per-machine.
- Does **NOT** contain: credentials, builds, changelogs, project status, lessons learned.
- Never duplicate information that exists in other documents â€” only point to them with references.

### Layer 2: Reference Documents
- Specialized documents: ARCHITECTURE, CREDENTIALS, BUILD COMMANDS, etc.
- Each document has a single purpose. If a piece of data fits in more than one document, it goes in the most specific one.
- The project container holds the working memory for active projects.

### Layer 3: Module Context
- Describe the code **as it IS**: what the module does, what patterns it follows, known pitfalls.
- Do **NOT** contain: project status, changelogs, pending tasks.
- They are stable â€” they only change when the code they accompany changes.
- **Always live on disk alongside the code**, regardless of provider. Claude Code reads them natively. They are code documentation, not project documentation.

### Separation Rule

| Type of information                          | Where it goes                                              |
|----------------------------------------------|------------------------------------------------------------|
| Provider config, user identity               | `claude-memory/CONFIG.md` (on disk, gitignored)            |
| What this module does, patterns, pitfalls    | Module context document for `src/{module}/`                |
| Scope, requirements, acceptance criteria     | Project's SPECIFICATIONS document                          |
| Prior analysis, mappings, constraints        | Project's TECHNICAL ANALYSIS document                      |
| Phase plan, files, order                     | Project's PLAN document                                    |
| Deliverable technical documentation          | Project's TECHNICAL REPORT document                        |
| Project status, next step                    | Project's CURRENT STATUS document                          |
| Test scenarios, edge cases, acceptance tests | Project's TESTING document                                 |
| Project change history                       | Project's CHANGELOG document                               |
| Reusable technical lessons                   | LESSONS LEARNED document                                   |
| Credentials and endpoints                    | CREDENTIALS document                                       |
| Build commands                               | BUILD COMMANDS document                                    |
| Global system architecture                   | ARCHITECTURE document                                      |
| User's active projects and project index     | Provider's project index                                   |
| Provider entity ID cache (auto-generated)    | `claude-memory/PROVIDER_CACHE.md` (gitignored, on disk)   |

> **Provider note**: The specific format and location of each document depends on your chosen provider. See `claude-memory/providers/{provider}/MAPPING.md` for how framework concepts map to provider entities.

---

## Naming

- **UPPERCASE** for reference documents: ARCHITECTURE, CHANGELOG, PLAN, CURRENT STATUS
- **snake_case** for scripts generated by Claude or the user
- **No spaces**, no special characters, no accents in names
- **No status suffixes** in names â€” status is managed ONLY in the project index
- **Language**: English for document names; content in English or your team's language as needed

## Project Container Naming

- **kebab-case**: `auth-refactor`, `api-migration`, `checkout-fix`
- No status suffixes: ~~`auth-refactor-IN_DEVELOPMENT`~~ â†’ `auth-refactor`

---

## Multi-User Mode

### Configuration

User identity is set in `claude-memory/CONFIG.md` (gitignored, per-user):

```
## User
current_user: Eugenio
```

When `current_user` is NOT set, the framework operates in **single-user mode** (backward compatible with all existing behavior).

The `current_user` value must match the user's identity in the provider (e.g., ClickUp display name, email) so the provider can resolve ownership.

### Ownership

- Project ownership is tracked in the provider's project index using the native mechanism for the provider (e.g., assignee field in ClickUp, metadata in markdown files).
- All projects are freely accessible to all users. Ownership indicates who is currently responsible, not access restriction.
- When `current_user` is set, Claude:
  - **Creates** new projects with ownership set to `current_user`
  - **Filters** the project index by owner when listing "my projects"
  - **Can read and modify** any project regardless of owner

### What Is Scoped Per User vs. Shared

| Concept | Scope | Rationale |
|---|---|---|
| Project containers | **Per-user** ownership | Each user's work is identified |
| Project index entries | **Per-user** ownership | Filterable by owner |
| Project documents (CURRENT STATUS, etc.) | **Per-user** ownership (inside the user's project) | Session context is personal |
| Reference documents (ARCHITECTURE, etc.) | **Shared** â€” team-level | Team knowledge |
| Module context (`{module}/CLAUDE.md`) | **Shared** â€” code-level | Code documentation, not project documentation |
| LESSONS LEARNED | **Shared** â€” team-level | Reusable across the team |
| CREDENTIALS | **Shared** â€” team-level | Same environments for all |

### Single-User Fallback

When `current_user` is NOT set:
- Projects have no owner assigned
- No filtering applied â€” all projects are listed
- Behaves identically to single-user mode

---

## Project Lifecycle

### 1. Create project
- Create a project container in the provider (see provider MAPPING.md for the specific entity type)
- Create the CURRENT STATUS document (mandatory from the very start)
- Create the SPECIFICATIONS document with the initial scope, requirements, and acceptance criteria
- Register in the project index with status `PLANNING` and assign ownership to `current_user`

### Small Projects (Lite Mode)
If the project is a fix, a scoped refactor, or a task spanning only a few sessions (plan with fewer than 3 phases):
- Only CURRENT STATUS + CHANGELOG â€” do not create SPECIFICATIONS, TECHNICAL ANALYSIS, PLAN, TECHNICAL REPORT, or TESTING
- Requirements, analysis, and plan go as sections inside CURRENT STATUS
- If the project grows and becomes complex, promote to full structure at that point

### 2. ANALYSIS Phase (status: `PLANNING`)
The first sessions are dedicated to understanding the problem, analyzing the existing code involved, identifying constraints, and defining the approach. These are the sessions that generate the most context and where distillation is most critical.

**Primary output**: TECHNICAL ANALYSIS
- Analysis of the problem or requirement to be solved
- Existing code involved: modules, classes, patterns, dependencies
- Relevant data structures (tables, models, relationships)
- Constraints and limitations discovered
- Design decisions made prior to development (e.g., "approach X, not Y, because...")
- If it's an API integration: endpoints, auth, rate limits, external data model, field-to-field mappings
- **Impact map** (recommended): existing files affected, tables read/written, artifacts/binaries involved. Helps Claude assess the real scope before planning.

**Audience**: Claude in future sessions. Discarded when the project is closed.

### 3. PLANNING Phase (status: `PLANNING`)
With the analysis done, the concrete implementation plan is defined.

**Primary output**: PLAN
- Ordered phases with description and dependencies
- Files to create or modify per phase, with expected content
- Database changes needed (tables, stored procedures, views, migrations)
- Phase-specific implementation considerations
- Suggested implementation order

**Audience**: Claude in future sessions. Discarded when the project is closed.

### 4. DEVELOPMENT Phase (status: `IN_PROGRESS`)
Iterative implementation phase by phase. Each session produces code and updates memory.

**Primary output**: TECHNICAL REPORT
- Technical documentation of the project, enriched as development progresses
- Reflects what was built: files, classes, methods, data structures
- Technical decisions made during implementation and their rationale
- Project-specific lessons learned
- Status of each phase (completed / pending)
- File structure of the developed component
- Optionally, a "Notes for the deployer" section. Relevant data to keep in mind when configuring or deploying the feature.
For example, "External dependencies MUST be configured BEFORE running the data import". These are details to keep in mind when setting up the functionality.

**Audience**: Engineering team. **Survives project closure** as deliverable technical documentation.

### 5. TESTING Phase (status: `TESTING`)
Development completed. Validation, QA, pre-production vs production comparison.

**Primary output**: TESTING
- Test scenarios derived from SPECIFICATIONS acceptance criteria
- Edge cases discovered during development or testing
- Test results: passed, failed, pending
- Verification against SPECIFICATIONS: which requirements are met and which are not
- Environment-specific considerations (pre-production vs production differences)

### 6. Complete (status: `RELEASED`)
When the project is released to production:
- TECHNICAL REPORT â†’ **kept** as technical documentation
- SPECIFICATIONS â†’ **kept** alongside TECHNICAL REPORT as the original requirements reference
- TESTING â†’ **kept** alongside TECHNICAL REPORT as the verification record
- TECHNICAL ANALYSIS, PLAN â†’ can be discarded (their value is already reflected in TECHNICAL REPORT)
- CHANGELOG â†’ archive if applicable
- Archive or close the project container in the provider
- Update the project index: move the entry to RELEASED status
- If the project generated module context documents, those **are kept** (they are code context, not project context)

### Project Statuses (in the project index)

| Status          | Phase                     | Meaning                                          |
|-----------------|---------------------------|--------------------------------------------------|
| `PLANNING`      | Analysis + Planning       | Problem analysis, plan design                    |
| `IN_PROGRESS`   | Development               | Active implementation phase by phase             |
| `TESTING`       | Testing                   | Development done, QA validation                  |
| `READY`         | Pre-release               | Tested and ready for production                  |
| `RELEASED`      | Completed                 | In production (remove project container)         |
| `ON_HOLD`       | Paused                    | Temporarily paused                               |

> **Provider note**: These statuses should be mapped to the provider's native status system where possible (e.g., ClickUp native statuses on the Project Index List/Space). This avoids dependency on custom fields that may not be creatable via API.

### Document Evolution Throughout the Project

```
PLANNING          IN_PROGRESS       TESTING         RELEASED
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€       â”€â”€â”€â”€â”€â”€â”€         â”€â”€â”€â”€â”€â”€â”€â”€
CURRENT STATUS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ (always)
SPECIFICATIONS â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘  (created at project start, survives â†’)
TECHNICAL ANALYSIS â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘  (created and completed here)
PLAN              â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘  (created here)
CHANGELOG         â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘  (grows here)
TECHNICAL REPORT   â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  (grows here, survives â†’)
TESTING           â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘  (created here, survives â†’)
Module context    â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  (created/updated here)
```

---

## Standard Project Documents

| Document                 | Mandatory | Created in phase | Audience       | Survives closure |
|--------------------------|-----------|------------------|----------------|------------------|
| CURRENT STATUS           | Yes       | Project creation | Claude         | No               |
| SPECIFICATIONS           | Yes       | Project creation | Claude/Team    | **Yes**          |
| TECHNICAL ANALYSIS       | Yes       | Analysis         | Claude         | No               |
| PLAN                     | Yes       | Planning         | Claude         | No               |
| CHANGELOG                | Yes       | Development      | Claude/Team    | Optional         |
| TECHNICAL REPORT         | Yes       | Development      | Engineering    | **Yes**          |
| TESTING                  | Yes       | Testing          | Claude/Team    | **Yes**          |

### What Goes Where (practical rule)

**In SPECIFICATIONS** â€” What is being asked for:
- Scope: what the project must accomplish
- Functional requirements: what the system must do
- Non-functional requirements: performance, security, compatibility constraints
- Acceptance criteria: how to know each requirement is met
- Out of scope: what is explicitly NOT part of this project

**In TECHNICAL ANALYSIS** â€” What Claude discovers during investigation:
- Existing code involved, affected modules, dependencies
- Relevant data structures, relationships between tables
- Technical constraints, limitations, edge cases
- Design decisions prior to development
- If it's an API integration: endpoints, auth, rate limits, field-to-field mappings

**In PLAN** â€” What Claude is going to do:
- Ordered phases with files to create/modify
- Dependencies between phases
- Database changes, wiring, configuration

**In TECHNICAL REPORT** â€” What Claude has built:
- Files created, classes, methods, constants
- Technical decisions made during implementation
- Project-specific lessons learned

**In CURRENT STATUS** â€” Where we are now:
- What was completed, what remains, concrete next step

**In CHANGELOG** â€” What changed and when:
- Code changes with files and reason

**In TESTING** â€” How we verify what was built:
- Test scenarios tied to SPECIFICATIONS acceptance criteria
- Edge cases and negative tests
- Test results and pass/fail status
- Environment-specific notes

**In LESSONS LEARNED** â€” What's reusable across projects:
- Only lessons that apply beyond this specific project

### Key Difference Between the Technical Documents

```
SPECIFICATIONS  â†’ TECHNICAL ANALYSIS â†’ PLAN          â†’ TECHNICAL REPORT â†’ TESTING
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”€â”€â”€â”€â”€â”€          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”€â”€â”€â”€â”€â”€â”€
What is asked?    What exists?         What to do?     What was built?      Does it work?

Requirements,     Existing code,       Phases, files,  Classes, methods,    Test scenarios,
acceptance        constraints,         order, deps,    technical decisions, results,
criteria,         data structures,     DB changes,     lessons, file        edge cases,
scope             prior decisions      configuration   structure            verification

For Claude/Team   For Claude           For Claude      For Engineering      For Claude/Team
Survives          Discarded            Discarded       Delivered            Survives
```

---

## Module Context Document (template)

```markdown
# {Module Name}

## What this is
- Description in 2-3 lines of what this module does

## Dependencies
- Framework, libraries, and references used by this module
- E.g.: "React 18, TanStack Query v5, Zod for validation" or "Django 4.2, Celery, PostgreSQL 15"

## Key patterns
- Design patterns and important conventions in the module

## Files
- List of files with a one-line description

## Watch out
- Known pitfalls, common mistakes, things NOT to do
```

Guidelines:
- Maximum ~50 lines. If it needs more, something belongs in a different document.
- Direct, imperative language: "Always validate input before processing", "Never call this method outside the main thread".
- Only information Claude needs to work with the code â€” no history or changelogs.
- The Dependencies section is especially important in legacy stacks or frameworks with constrained versions: Claude tends to suggest APIs from newer versions that may not be available.

---

## Session Distillation Protocol

### The Problem
Claude Code's context window runs out. If you don't distill before that happens, the session's work is lost or trapped in conversation transcripts that are noisy and inefficient to reprocess.

### The Principle
> **Each session starts by reading clean documents and ends by updating them.** Never depend on conversation transcripts as a memory source.

### Distillation Triggers
Claude MUST execute the distillation protocol when:
1. **The user asks for it** â€” key phrases: "consolidate", "distill", "save progress", "persist the session"
2. **The context is filling up** â€” Claude must propose it proactively
3. **A significant block of work is completed** â€” a phase, an important fix, an analysis
4. **Before switching topics** â€” if transitioning from analysis to coding or vice versa

### What to Update (checklist by phase)

**During ANALYSIS sessions:**
| Document | Priority | What to write |
|------|----------|---------------|
| TECHNICAL ANALYSIS | **Primary** | Findings: existing code, data structures, constraints, design decisions |
| SPECIFICATIONS | If requirements changed | Update scope, acceptance criteria, clarified constraints |
| CURRENT STATUS | **ALWAYS** | "Analysis of X completed, still need to analyze Y" |

**During PLANNING sessions:**
| Document | Priority | What to write |
|------|----------|---------------|
| PLAN | **Primary** | Phases, files to create/modify, order, dependencies |
| TECHNICAL ANALYSIS | If applicable | Enrich if new findings emerged while planning |
| CURRENT STATUS | **ALWAYS** | "Plan completed, next step: implement phase 1" |

**During DEVELOPMENT sessions:**
| Document | Priority | What to write |
|------|----------|---------------|
| CURRENT STATUS | **ALWAYS** | What was done, what's left, concrete next step to resume |
| TECHNICAL REPORT | **Primary** | Document what was built: classes, methods, technical decisions |
| CHANGELOG | If there were changes | Concrete changes with files and reason |
| LESSONS LEARNED | If applicable | Only if reusable across projects |
| Module context | **Mandatory if module logic was modified** | Updated patterns, pitfalls, files, dependencies |

**During TESTING sessions:**
| Document | Priority | What to write |
|------|----------|---------------|
| TESTING | **Primary** | Test scenarios, results, edge cases, verification against SPECIFICATIONS |
| CURRENT STATUS | **ALWAYS** | What was tested, what passed/failed, next step |
| TECHNICAL REPORT | If applicable | Update with testing-related technical findings |

### CURRENT STATUS Format When Distilling

```markdown
**Last updated**: YYYY-MM-DD
**Last session summary**: [1-2 sentences of what was done]
**Next step**: [Concrete action to resume â€” not "continue development"]
**Done when**: [Verification condition â€” how to know the next step is completed]

## Done
- âœ… What's completed (cumulative)

## In Progress
- ðŸ”„ What's in progress + exact state

## Next Steps
- [ ] What's pending, ordered by priority

## Blockers
- (if any)
```

The key to `**Next step**` is that it must be **concrete enough that Claude can resume without asking anything**.
The key to `**Done when**` is that it must be **verifiable**: a command, a result, a passing test.

Examples:
- âŒ Next step: "Continue with phase 3" / Done when: "When it's ready"
- âœ… Next step: "Implement UserService.validate(): add email format check + duplicate detection against DB"
- âœ… Done when: "All tests in test_user_service.py pass + manual test: registering duplicate email returns 409"

### Full Workflow Between Sessions

```
Session N
  â”œâ”€â”€ Boot sequence: CLAUDE.md â†’ CONFIG.md â†’ CONVENTIONS â†’ PROVIDER_CACHE
  â”œâ”€â”€ Claude reads project index â†’ knows active projects
  â”œâ”€â”€ Claude reads CURRENT STATUS â†’ knows exactly where to resume
  â”œâ”€â”€ If it needs analysis context â†’ reads TECHNICAL ANALYSIS
  â”œâ”€â”€ If it needs the plan â†’ reads PLAN
  â”œâ”€â”€ If it needs code context â†’ reads the module context document
  â”œâ”€â”€ Work together (analysis, code, decisions...)
  â”œâ”€â”€ âš ï¸ Distillation trigger detected
  â”‚     â”œâ”€â”€ Claude proposes: "I'm going to consolidate the session progress"
  â”‚     â”œâ”€â”€ Claude updates documents for the current project
  â”‚     â””â”€â”€ If new entities were created â†’ updates PROVIDER_CACHE.md
  â””â”€â”€ End of session â€” clean context for the next one

Session N+1
  â”œâ”€â”€ Boot sequence (same as above)
  â”œâ”€â”€ Claude reads CURRENT STATUS (â‰¤50 lines, ~10 sec of context)
  â”œâ”€â”€ Reads "Next step" â†’ knows the concrete action
  â”œâ”€â”€ If there's a "Done when" from the previous session â†’ recommended to validate before moving forward
  â””â”€â”€ Starts without having loaded any transcripts from previous sessions
```

> **Multi-user note**: Distillation targets only the `current_user`'s projects. Shared documents (LESSONS LEARNED, module context) are updated normally regardless of user.

### Anti-pattern: conversation transcripts
- Do **NOT** save conversations as files to "remember"
- Do **NOT** ask Claude to read transcripts from past sessions
- If a transcript already exists and has valuable info â†’ distill to structured documents and discard the transcript
- Everything valuable from a conversation **must be distilled** before it ends

### Staleness Rule
If Claude reads a CURRENT STATUS whose `Last updated` date is more than 48 hours old, it must ask the user if the information is still valid before assuming it is. Code may have changed outside of Claude (manual hotfixes, merges from other developers, DB changes).

In multi-user mode, the staleness rule applies per user. Only the `current_user`'s CURRENT STATUS age matters â€” other users' document ages are irrelevant to the current session.

---

## Persistence Rules

1. Distill at the end of every session or significant block of work (mandatory)
2. Reusable technical finding â†’ LESSONS LEARNED
3. New useful command â†’ BUILD COMMANDS or a scripts container
4. New pattern or pitfall in a module â†’ module context document
5. **If a session modifies a module's architecture, patterns, or dependencies, updating its module context is mandatory** â€” not optional
6. **Never duplicate** â€” if data already exists in another document, reference it
7. New credentials â†’ CREDENTIALS (remember: this document must not be versioned / must have restricted access)
8. Operational debugging guides (timeouts, incorrect counts, cache) â†’ TESTING METHODOLOGY

## LESSONS LEARNED Structure

Organize by categories with `##` headers:
```markdown
## Concurrency
- Race condition in shared cache â†’ always use locks or thread-safe collections
- ...

## API / Networking
- ...

## Database
- ...
```

**Pruning rule**: LESSONS LEARNED acts as an incubator, not a permanent archive. When a lesson matures and becomes a standard for a specific module, it should be moved to that module's context document ("Watch out" section) and removed from the general document.

**Size trigger**: When LESSONS LEARNED exceeds 30 entries, Claude must prune during distillation: review all entries, move mature lessons to the relevant module context documents, and remove them from LESSONS LEARNED. If no entries qualify for migration, consolidate related entries or archive obsolete ones. The goal is to stay under the threshold.

## Cross-referencing Rule

Before creating something new, Claude must **read the existing equivalent first** as a reference:
- New service â†’ read the context and code of an existing similar service
- New form â†’ read a similar existing form
- New stored procedure â†’ read an equivalent SP following the same pattern
- New module â†’ read the context document of a similar module

This applies to any type of project, not just integrations.

## Log Access Rule

Claude must **never** read all items in a logs container at once. It must read only the specific entry it is debugging. Loading multiple logs floods the context unnecessarily.

## Temporary Data

Temporary files, intermediate outputs, and ephemeral data generated during a session (e.g., exported data, test payloads, diff snapshots) should be stored in a designated temporary area. This data can be cleaned at any time.

---

## Version Control

How changes to documents are tracked depends on the provider:
- **Markdown files**: git commits, branches, `.gitignore` for sensitive documents
- **ClickUp / Notion / etc.**: Native edit history, restricted permissions for sensitive documents

See your provider's MAPPING.md for specific version control guidance.

### Documents that must NOT be publicly versioned
- CREDENTIALS (sensitive)
- PROVIDER_CACHE (auto-generated, machine-specific)
- Logs (heavy, temporary)
- Temporary data (ephemeral)

---

## Provider Cache

### Purpose

External/hybrid providers require entity ID lookups (Space IDs, Folder IDs, List IDs, Doc IDs) for every MCP operation. The Provider Cache eliminates this overhead by mapping framework document names to provider-specific entity IDs on disk.

### Scope

- **Required for**: External and hybrid providers (ClickUp, Notion, etc.) that access documents via MCP tools
- **Not needed for**: The markdown-files provider (all documents are local files â€” no IDs to cache)
- **File location**: `claude-memory/PROVIDER_CACHE.md` (gitignored â€” never committed to version control)

### Cache Rules

1. **Auto-generated** â€” Claude generates the cache file, never the user
2. **Gitignored** â€” The cache is local and machine-specific; never committed
3. **Read on startup** â€” Claude reads PROVIDER_CACHE.md after CONFIG.md, before any provider operations (except CONVENTIONS)
4. **Use cached IDs first** â€” When the cache has an ID for an entity, Claude uses it directly instead of searching/listing via MCP
5. **Update on create** â€” When Claude creates a new entity (project container, document, page, etc.), it appends the new ID to the cache immediately
6. **Regenerate if missing or corrupted** â€” If the file is missing or a cached ID returns "not found", Claude regenerates the entire cache from scratch

### Cache Lifecycle

| Event | Action |
|---|---|
| First session with external provider (no cache file) | Claude generates the cache by querying the provider |
| Session start | Claude reads the cache file alongside CLAUDE.md |
| Claude creates a new entity (project, document) | Claude appends the new ID to the cache |
| Cached ID returns "not found" from provider | Claude regenerates the entire cache |
| Cache file manually deleted | Same as "first session" â€” Claude regenerates |

### What Is Cached

The cache maps every framework entity to the provider's entity IDs. For external providers this typically includes:

- Workspace/Space/Folder IDs (infrastructure)
- Document IDs (reference docs, project containers)
- Page/Section IDs (individual project documents within containers)
- Task/Item IDs (project index entries)
- Owner information (for quick filtering without API calls)

### Cache Template

The exact structure depends on the provider. See the provider's `MAPPING.md` â†’ "Provider Cache" section for the specific cache template and format.
